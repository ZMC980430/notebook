# GET和POST请求的区别

![1680530637775](image/我还需要更多/1680530637775.png)

1.报文上的区别
GET 和 POST 只是 HTTP 协议中两种请求方式，所以在传输上，没有区别，因为HTTP 协议是基于 TCP/IP 的应用层协议
报文格式上，不带参数时，最大区别仅仅是第一行方法名不同，一个是GET，一个是POST
带参数时报文的区别呢？在约定中，GET 方法的参数应该放在 url 中，POST 方法参数应该放在 body 中
举个例子，如果参数是 name=qiming.c, age=22。
GET 方法简约版报文可能是这样的
GET /index.php?name=qiming.c&age=22 HTTP/1.1
Host: localhost

POST 方法简约版报文可能是这样的
POST /index.php HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded name=qiming. c&age=22

2.GET 方法参数写法是固定的吗？
在约定中，一般我们的参数是写在 ? 后面，用 & 分割。
我们知道，解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。
也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行，一种比较流行的写法是这样 :
http://www.example.com/user/name/yourname/age/22

3、POST 方法比 GET 方法安全？
按照网上大部分文章的解释，POST 比 GET 安全，因为数据在地址栏上不可见。
然而从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输，只要在网络节点上抓包，就能完整地获取数据报文。
要想安全传输，就只有加密，也就是 HTTPS

# 零拷贝

提高读写性能

# 强引用、软引用、弱引用、虚引用

# Mysql

不能轻易删除大量数据，会产生大量redo log，会造成很大磁盘占用，非常耗时

# Class 文件加载

![img](image\我还需要更多\1691659473566.png)

据说字符串常量池中的字符串在被引用两次之后会在堆内也有，然后字符串引用都指向堆中，常量池中的字符串便会被GC回收

# Java 内存模型

* 在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递
* **局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收**

# 为什么不使用自增ID或UUID做主键，要使用雪花算法

- 如果使用基于主键范围分片，那么压力会集中在某个分片上
- 使用AUTO_INCREMENT 和 replace into，那么每次插入数据时会占用自增锁和插入锁
- 多表合并时可能产生数据冲突
- 多节点都有自己的自增id，可能会数据冲突
- UUID虽可以分布式不重复，但无法保证有序，由于mysql存储时按照主键的顺序，使用UUID会导致新增数据频繁地插入到已有数据中，可能导致大量的数据页改动
- 雪花算法首位为0，后41位为时间戳，能表示69年，再往后10位为机器编号，再后面12位为序列号
- 雪花算法可保证唯一性和自增性，为了避免时间戳时间限制，可使用当前时间减去上线时间
- 雪花算法会受到机器时钟影响，如果出现时间回拨，会造成错误。

# TLAB

TLAB对Eden区划分，为每个线程划分一个私有缓存区，成为快速分配策略。堆区线程共享，不同线程创建对象划分内存时可能会线程不安全，为了避免多个线程操作同一个内存区域。默认情况TLAB占1%的空间，一旦在缓存区分配失败，会通过加锁机制来在Eden区中分配内存

# 逃逸分析

若一个对象生存周期只在一个方法内部，可以判断没有逃逸，可进行优化：栈上分配，不考虑同步操作，若对象不需要作为一个连续内存结构存在，可以将部分或全部存储在CPU寄存器，而不是内存

# 方法区

- 包含常量池，存放运行时字面量和符号引用，这部分在类加载后存放在常量池，运行时也可以存入，常用String.intern()方法。
- 方法区大小决定了可以加载多少个类
- 永久代和元空间都是方法区的具体实现。永久代和新生代老年代的物理地址是连续的，受GC管理，元空间在本地内存（堆外内存），不受JVM限制。
- 元空间有个高水位线，当占用空间达到这个高水位线时会触发Full GC，然后高水位线会被重置，释放多则水位线下降。若初始水位线较低，则会频繁Full GC

## 内部结构

### 类型信息：

对类、接口、枚举、注解等要包含类型信息，包括完整有效名称（包名.类名）、父类完整有效名、修饰符、直接接口的一个有序列表

### 域信息（field）：

保存类型的所有于相关信息以及声明顺序，包括域名称，域类型，域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）

### 方法信息：

保存方法名，返回类型，参数数量类型，修饰符，字符码，操作数栈，局部变量表以及大小，异常表

### 常量池：

一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用。

一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。

常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。

每个已加载的类型都有一个常量池，其中的数据类似数组项，通过索引访问。其中包含一些数值字面量，还有常量池中的符号地址，在运行时常量池会转换为真实地址

# Spring注入

若Bean只有一个构造器，会直接注入，无需写Autowired
