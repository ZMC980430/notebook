# Java 并发编程

volatile的底层实现：对内存区域的缓存加lock（缓存行锁定）

1. 将当前处理器缓存行的数据立即写回内存
2. 写回操作使其他cpu的缓存该地址的数据无效（内存一致性协议）
3. 提供内存屏障功能，使lock前后指令不能重排

## mesi 内存一致性协议

变量有四种状态，初始都是shared，当有一个修改了之后回立刻同步到进程中共享内存，然后总线上嗅探机制将其他线程的同一个变量的复制标记为invalid，当需要使用时再从进程中获取

并发三大特性：可见性，有序性，原子性

计算机会指令重排，导致执行顺序与代码不一致

java重排序规范：as-if-serial 和 happens-before

## 内存屏障

| 屏障           | 指令实例                       | 说明                                                                          |
| -------------- | ------------------------------ | ----------------------------------------------------------------------------- |
| `LoadLoad`   | `Load1; LoadLoad; Load2`     | 保证 `Load1` 在 `Load2` 以及后续的读操作之前执行                          |
| `StoreStore` | `Store1; StoreStore; Store2` | 在 `Store2` 以及后面写操作执行前，保证 `Store1` 的写操作已经刷新到内存    |
| `LoadStore`  | `Load1l; LoadStore; Store2`  | 在 `Store2` 以及后面写操作执行前，保证 `Load1` 的读操作已经结束           |
| `StoreLoad`  | `Store1; StoreLoad; Load2`   | 保证 `Store1` 的写操作已经刷新到内存后，`Load2` 以及之后的读操作才能执行 |

在汇编中加了一行，保证指令不会重排
